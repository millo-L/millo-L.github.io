{"componentChunkName":"component---src-components-post-post-template-tsx","path":"/WebRTC-implementation-method-Mesh-SFU-MCU/","result":{"data":{"markdownRemark":{"html":"<h2 id=\"1-introduction\" style=\"position:relative;\"><a href=\"#1-introduction\" aria-label=\"1 introduction permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Introduction</h2>\n<p>As I wrote in the last post, WebRTC works with ICE, STUN, TURN, and SDP. It would be very simple if it worked only with these servers and protocols, but the reality is not. To complete a P2P connection, a developer must create a server that relays session information through offers and answers between peers. However, it is not recommended to support data transmission/reception of 3, 4, and more people through a P2P connection because the client side is heavily overloaded.\nThe solution to this problem is to have SFU and MCU type media server.</p>\n<h2 id=\"2-type-of-server\" style=\"position:relative;\"><a href=\"#2-type-of-server\" aria-label=\"2 type of server permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Type of Server</h2>\n<p>There are three main types of servers that developers can implement for WebRTC. Signaling, SFU and MCU. If so, let’s look at them one by one.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1046px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/017a91d3df72ed6117dcdb47fab3c810/21b4d/webrtc-server.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.10687022900763%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAPoAAAD6AG1e1JrAAABtElEQVR42pWPW4/SQBSA+Wvwp9z44MbICyJmX0xMzEI0GkFDYDfRsCy7hl3uxhS7LAG5tqUM007pjWmp7RSHm+KbnpxMzvlmvsk5gdRF8n0+uT3/NwOrfai2ojvG6iCQjSzXPiT0jeu7v9u17MEBvEmOrk5BM2d2K8SQHPGekvF1HLIFd9ggWHXGDCV88bXMfsG9ir80dzK9lj8+7iQeCLlX8s1bgninU4QfjnuJI7EQR7fvPG3qsBez1KPem4dcPq6Vkr4538s8a1y+ELIxWEpJtQxRp/Q7SsSz57NyGtWz61k6xT3JrAlWdzIN4jq1evanpR9uCJDE9W8PCQ9FcVT7a2cgdob3FShyMpi0y1fCXal1V9Dk0dzAhJB++7sxG39rnM/RiOe6MzT5wVSxAnayjRcC35fmC0lCIpD9TTiu9/TZiaJZWIG2jSnBGh+NRmRFoOZyae1kDFmWqSMV02yUqzoYUMhWXxLiKhOhVc/T1vc9phjzXE9ofe2y1T9jIwPoJtj2NoKajmhhWsbG8bGpb4stWfsChxCyLCvQ7DXD6fBn5hMt/iXLzUooFAoGg+HIk1/QPDn/om13fAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"webrtc server\"\n        title=\"\"\n        src=\"/static/017a91d3df72ed6117dcdb47fab3c810/1c1a4/webrtc-server.png\"\n        srcset=\"/static/017a91d3df72ed6117dcdb47fab3c810/8ff13/webrtc-server.png 262w,\n/static/017a91d3df72ed6117dcdb47fab3c810/3e286/webrtc-server.png 523w,\n/static/017a91d3df72ed6117dcdb47fab3c810/1c1a4/webrtc-server.png 1046w,\n/static/017a91d3df72ed6117dcdb47fab3c810/21b4d/webrtc-server.png 1280w\"\n        sizes=\"(max-width: 1046px) 100vw, 1046px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3 id=\"21-signaling-serverp2pmesh\" style=\"position:relative;\"><a href=\"#21-signaling-serverp2pmesh\" aria-label=\"21 signaling serverp2pmesh permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2–1. Signaling Server(P2P/Mesh)</h3>\n<h4>Features</h4>\n<ul>\n<li>It relays only the session information signal of offer and answer between peers. Therefore, the load on the server occurs only when WebRTC relays information between peers for the first time.</li>\n<li>After the connection between peers is completed, there is no additional load on the server.</li>\n<li>It is suitable for 1:1 connection.</li>\n</ul>\n<h4>Advantages</h4>\n<ul>\n<li>Because the server load is low, the server resources are low.</li>\n<li>Real-time is guaranteed because data is transmitted and received through direct connection between peers.</li>\n</ul>\n<h4>Disadvantages</h4>\n<ul>\n<li>In 1:N or N:M connections, the overload of the client increases rapidly.\nFor example, assuming that 5 people connect to WebRTC as shown in the picture above, there are 4 Uplink (the number of sending my data to other connected users) and 4 Downlink (the number of connecting other users’ data coming to me). It maintains 8 links and transmits and receives data. (In the figure, data exchange is expressed as a link.)</li>\n</ul>\n<h3 id=\"22-sfuselective-forwarding-unit-server\" style=\"position:relative;\"><a href=\"#22-sfuselective-forwarding-unit-server\" aria-label=\"22 sfuselective forwarding unit server permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2–2. SFU(Selective Forwarding Unit) Server</h3>\n<h4>Features</h4>\n<ul>\n<li>It is a central server method that relays end-to-end media traffic.</li>\n<li>It connects the peer between the server and the client, not between the client peers.</li>\n<li>In all connection types such as 1:1, 1:N, N:N or N:M, the client only needs to send its own video data to the server without having to send data to all connected users (that is, 1 Uplink).</li>\n<li>However, if it is a 1:N, N:N or N:M format, you need to maintain peers that receive data as many as the number of peers. (Downlink is the same as in the case of P2P/Mesh (Signaling Server))</li>\n<li>It is suitable for real-time streaming in 1:N format or small N:M format.</li>\n</ul>\n<h4>Advantages</h4>\n<ul>\n<li>Although data passes through a server and is slower than when using a signaling server (P2P/Mesh), it can maintain a similar level of real-time.</li>\n<li>The load on the client is reduced compared to using a signaling server.</li>\n</ul>\n<h4>Disadvantages</h4>\n<ul>\n<li>Server cost increases compared to signaling server.</li>\n<li>In a large-scale N:M structure, the client still handles a lot of load.</li>\n</ul>\n<h3 id=\"23-mcumulti-point-control-unit-server\" style=\"position:relative;\"><a href=\"#23-mcumulti-point-control-unit-server\" aria-label=\"23 mcumulti point control unit server permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2–3. MCU(Multi-point Control Unit) Server</h3>\n<h4>Features</h4>\n<ul>\n<li>It is a central server method in which multiple transmission media are mixed (muxed) or processed (transcoding) in a central server and delivered to the receiving side.\n<em>For example, if 5 people connect to WebRTC, the video data of 4 people except one of them is edited into one video data, and the audio data is also edited and sent to one person. The same applies to the remaining 4 people.</em></li>\n<li>It connects the peer between the server and the client, not between the client peers.</li>\n<li>In all connection types, the client only needs to send its own video data to the server without having to send data to all connected users (ie, there is 1 Uplink).</li>\n<li>In all connection types, the client only needs to receive data from the server to one peer regardless of the number of connected users (i.e., 1 downlink).</li>\n<li>High computing power of the central server is required.</li>\n</ul>\n<h4>Advantages</h4>\n<ul>\n<li>The load on the client is significantly reduced (1 uplink and 1 downlink, total 2)</li>\n<li>It can be used for N:M architecture (I’m not sure if it can be said to be suitable… more suitable than other servers).</li>\n</ul>\n<h4>Disadvantages</h4>\n<ul>\n<li>Real-time, the biggest advantage of WebRTC, is hampered.</li>\n<li>Server cost is high in the process of combining video and audio.</li>\n</ul>\n<h2 id=\"references\" style=\"position:relative;\"><a href=\"#references\" aria-label=\"references permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[References]</h2>\n<ul>\n<li><a href=\"https://webrtcglossary.com/mixing/\">https://webrtcglossary.com/mixing/</a></li>\n</ul>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#1-introduction\">1. Introduction</a></p>\n</li>\n<li>\n<p><a href=\"#2-type-of-server\">2. Type of Server</a></p>\n<ul>\n<li><a href=\"#21-signaling-serverp2pmesh\">2–1. Signaling Server(P2P/Mesh)</a></li>\n<li><a href=\"#22-sfuselective-forwarding-unit-server\">2–2. SFU(Selective Forwarding Unit) Server</a></li>\n<li><a href=\"#23-mcumulti-point-control-unit-server\">2–3. MCU(Multi-point Control Unit) Server</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#references\">[References]</a></p>\n</li>\n</ul>","frontmatter":{"author":"millo","category":"webrtc","description":"Let's learn about the types of servers to implement WebRTC. (Mesh/P2P, SFU, MCU)","image":{"childImageSharp":{"fixed":{"src":"/static/5d1a4dc7a92facc014378e28932bee9a/497c6/webrtc.png"}}},"lang":"en","released_at":"2020-12-24 17:00","series":"WebRTC theory to practice","tags":["WebRTC","MCU","MediaServer","Mesh","P2P","SFU"],"title":"WebRTC implementation method(Mesh, SFU, MCU)","translation":"/WebRTC-구현-방식-Mesh-SFU-MCU/","updated_at":"2020-12-25 17:01"},"fields":{"slug":"/WebRTC-implementation-method-Mesh-SFU-MCU/"}},"allMarkdownRemark":{"nodes":[{"frontmatter":{"lang":"en","title":"About WebRTC"},"fields":{"slug":"/About-WebRTC/"}},{"frontmatter":{"lang":"en","title":"WebRTC implementation method(Mesh, SFU, MCU)"},"fields":{"slug":"/WebRTC-implementation-method-Mesh-SFU-MCU/"}},{"frontmatter":{"lang":"en","title":"Implementing WebRTC using ReactJS and Typescript (1:1 P2P)"},"fields":{"slug":"/Implementing-WebRTC-using-ReactJS-and-Typescript-1-1-P2P/"}},{"frontmatter":{"lang":"en","title":"Implementing WebRTC using ReactJS and Typescript (1:N P2P)"},"fields":{"slug":"/Implementing-WebRTC-using-ReactJS-and-Typescript-1-N-P2P/"}},{"frontmatter":{"lang":"en","title":"Implementing WebRTC using ReactJS and Typescript (1:N SFU)"},"fields":{"slug":"/Implementing-WebRTC-using-ReactJS-and-Typescript-1-N-SFU/"}},{"frontmatter":{"lang":"en","title":"WebRTC Performance Comparison (P2P vs SFU)"},"fields":{"slug":"/WebRTC-Performance-Comparison-P2P-vs-SFU/"}}]}},"pageContext":{"slug":"/WebRTC-implementation-method-Mesh-SFU-MCU/","series":"WebRTC theory to practice","translation":"/WebRTC-구현-방식-Mesh-SFU-MCU/","lang":"en"}},"staticQueryHashes":["2083168511","3061319093","3557473807","356676075"],"slicesMap":{}}