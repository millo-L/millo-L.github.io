{"componentChunkName":"component---src-components-post-post-template-tsx","path":"/WebRTC-이론-정리하기/","result":{"data":{"markdownRemark":{"html":"<h2 id=\"1-webrtc란-무엇일까\" style=\"position:relative;\"><a href=\"#1-webrtc%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C\" aria-label=\"1 webrtc란 무엇일까 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. WebRTC란 무엇일까?</h2>\n<ul>\n<li>WebRTC(Web Real-Time Communication)란 웹 브라우저 환경 및 Android, IOS 애플리케이션에서도 사용 가능한 비디오, 음성 및 일반 데이터가 <strong>피어간</strong>에 <strong>실시간</strong>으로 전송되도록 지원하는 <strong>오픈 소스</strong>이다.</li>\n<li>공개 <strong>웹 표준으로 구현</strong>되며 모든 주요 브라우저에서 일반 JavaScript API로 제공한다. (Apple, Google, Microsoft 및 Mozilla가 지원)</li>\n</ul>\n<h2 id=\"2-webrtc의-기술-및-프로토콜-소개\" style=\"position:relative;\"><a href=\"#2-webrtc%EC%9D%98-%EA%B8%B0%EC%88%A0-%EB%B0%8F-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-%EC%86%8C%EA%B0%9C\" aria-label=\"2 webrtc의 기술 및 프로토콜 소개 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. WebRTC의 기술 및 프로토콜 소개</h2>\n<h3 id=\"2-1-iceinteractive-connectivity-establishment\" style=\"position:relative;\"><a href=\"#2-1-iceinteractive-connectivity-establishment\" aria-label=\"2 1 iceinteractive connectivity establishment permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2-1. ICE(Interactive Connectivity Establishment)</h3>\n<ul>\n<li>브라우저가 <strong>peer를 통한 연결이 가능하도록 해주는 프레임 워크</strong>이다.</li>\n<li><strong>peer간 단순 연결 시 작동하지 않는 이유들</strong>\n<ul>\n<li>연결을 시도하는 <strong>방화벽</strong>을 통과해야 함</li>\n<li><strong>단말에 Public IP가 없다</strong>면 유일한 주소값을 할당해야 한다.</li>\n<li><strong>라우터가 peer간의 직접 연결을 허용하지 않을 때</strong> 데이터를 릴레이해야 하는 경우</li>\n</ul>\n</li>\n<li>ICE는 위의 작업들을 수행하기 위해 <strong>STUN</strong>과 <strong>TURN</strong> 서버 <strong>둘 다 혹은 하나</strong>의 서버를 사용한다.</li>\n</ul>\n<h3 id=\"2-2-stunsession-traversal-utilities-for-nat-서버\" style=\"position:relative;\"><a href=\"#2-2-stunsession-traversal-utilities-for-nat-%EC%84%9C%EB%B2%84\" aria-label=\"2 2 stunsession traversal utilities for nat 서버 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2-2. STUN(Session Traversal Utilities for NAT) 서버</h3>\n<ul>\n<li><strong>클라이언트 자신의 Public Address(IP:PORT)를 알려준다.</strong></li>\n<li>peer간의 직접 연결을 막는 등의 라우터의 제한을 결정하는 프로토콜 (현재 <strong>다른 peer가 접근 가능하지 여부</strong> 결정)</li>\n<li>클라이언트는 인터넷을 통해 <strong>클라이언트의 Public Address</strong>와 <strong>라우터의 NAT 뒤에 있는 클라이언트가 접근 가능한지에 대한 답변</strong>을 STUN서버에 요청한다.</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 259px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/f3467aed345c1199ea1e3ddd5928b672/a2ead/webrtc-stun.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 145.94594594594594%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAdCAYAAACqhkzFAAAACXBIWXMAAAsTAAALEwEAmpwYAAADc0lEQVR42qWVS0xTQRSGB2hpeQWKAvIoCpQSIQYxhGBUcGHc4LYbNiQuTFhoogtjwoJEEnzFIFFJCCRCQCSUpxjezwQtlBYsysteqCACtkQhYuvj0uOZ3guWBoSWSf6cmbk335wzc84MIYSEi0SiaLlcfjgiPj6Q+PkdIgdskQKBIBntGdonnp5x/Lyby8Sc+4Uxys6hR1UtA7ezs29JbJMALgMFyvYhlXZuFdQzK/Ci9XUlxwN3l2gZGZmSft3s8qDeZNUtrEO/jlHjtPuBwi6uenW3RTUB9f2jGwXlyst0rqamxmMPqJuddfxHI8zLeXC+8OrNVCDE30qIiP/gyYuOxfv0TyMUCuEU7lo0wnzMYt80CyFR9IuQkEQ0KSj8Tk7zUCG/CO3TKHzIPwdos+IAZH5ha7b8A+ITjGAZKgiHNIVSCdc/aUsrQmIIt2ASKgx1DiW3C98GxJ/An5uL8FogRIpAOQ+1/Yinvk18Jmztnd08oOsWGVo/HHhjFqWhjV3BCkJgHCrYyTPeAvriACVIwQ06jv0Q4BSVnpUlvqhQBNIUsylzZ53NyJDYA/mQQ71psivohtMwCDlWVlh6p2vEsN4zMrvcM2owdqM6NTPGjmE9ijG2q6eNvWNzxoqmXiMPtO1hAO+x/b7YclHZpso3rAMMMSZ2ePYraAyr8G7RAlMrGzBh/APjX34DswaAC8D+gB2DeQOTS1CqbPtV1tDNFpRWs9XtKvZpRSOLc2xRZRNb2zXEtg5OsvsC1nWo8ufMAGOLZvb90k94++k7UKsxfMP+Oox8XINJ0wZ0j87+38PN8ntcXn+jXcssdWn00x0aPdOpZRhqu7QzW/0+3TxT3tjD7AoEvj7RhmIKxRej5dJqT+3uIQ+kJRmLktgvtEcebgfaeSdBhf/A8oHcXHfHatlJO5TeVsgCVKSVwvAGcqJS5r0IWZNveqggCg8eGEJhVM6WHoIgmS+9zX0TU++AuyS8nQSKjwq9ZUlB0oQYqTQoBl89egDBZg52ZJ8Hsa3RkBJQ9CmVXsAnFQFhZs5DT5felIclz1PaBqdeNvbrKkqu59LL9YRFJJK54h1tXg29o+PqGROoGRPU9mib6TUPV4qFLnmXmJ4e0D3CfKY1OWlk8cb48MbhRXO+PXlWd62yuc9a0dy3eq+o8pLDM+pU+wspuupBb0NtzAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"webrtc stun\"\n        title=\"\"\n        src=\"/static/f3467aed345c1199ea1e3ddd5928b672/a2ead/webrtc-stun.png\"\n        srcset=\"/static/f3467aed345c1199ea1e3ddd5928b672/a2ead/webrtc-stun.png 259w\"\n        sizes=\"(max-width: 259px) 100vw, 259px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3 id=\"2-3-natnetwork-address-transilation\" style=\"position:relative;\"><a href=\"#2-3-natnetwork-address-transilation\" aria-label=\"2 3 natnetwork address transilation permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2-3. NAT(Network Address Transilation)</h3>\n<ul>\n<li>단말에 공개 IP(Public IP) 주소를 할당하기 위해 사용한다.</li>\n<li>라우터는 공개 IP 주소를 갖고 있고 모든 단말들은 라우터에 연결되어 있으며 비공개 IP주소(Private IP Address)를 갖는다.</li>\n<li>요청은 단말의 비공개 주소로부터 라우터의 공개 주소와 유일한 포트를 기반으로 번역한다. 이 덕분에, <strong>각각의 단말이 유일한 공개 IP 없이 인터넷 상에서 검색 가능하다.</strong></li>\n<li>몇몇의 라우터들은 <strong>Symmetric NAT</strong>이라고 불리우는 <strong>제한을 위한 NAT</strong>을 채용한다. 즉, <strong>peer들이 오직 이전에 연결한 적 있는 연결들만 허용</strong>한다. 따라서 <strong>STUN서버에 의해 공개 IP주소를 발견한다고 해도 모두가 연결을 할수 있다는 것은 아니다.</strong> (위의 설명에서 STUN 서버에 다른 peer가 접근 가능한지 여부를 요청하는 이유)</li>\n<li><strong>이를 위해 TURN이 필요하다.</strong></li>\n</ul>\n<h3 id=\"2-4-turntraversal-using-relays-around-nat-서버\" style=\"position:relative;\"><a href=\"#2-4-turntraversal-using-relays-around-nat-%EC%84%9C%EB%B2%84\" aria-label=\"2 4 turntraversal using relays around nat 서버 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2-4. TURN(Traversal Using Relays around NAT) 서버</h3>\n<ul>\n<li><strong>TURN 서버와 연결하고 모든 정보를 그 서버에 전달</strong>하는 것으로 <strong>Symmetric NAT 제한을 우회</strong>하는 것을 의미한다.</li>\n<li>이를 위해 <strong>TURN 서버와 연결</strong>을 한 후 <strong>모든 peer들에게 저 서버에 모든 패킷을 보내고 다시 나(TURN서버)에게 전달</strong>해달라고 해야 한다.</li>\n<li>명백히 <strong>오버헤드가 발생</strong>하므로 이 방법은 다른 <strong>대안이 없을 경우만 사용</strong>해야 한다.</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 295px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/5926b76eea820b8d89738432822f635f/e4a3f/webrtc-turn.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 100.76335877862594%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAsTAAALEwEAmpwYAAAC0klEQVR42q1UXUhTYRj+NDfdnJMSDW0HLSXKCKxJESTDq+rGoBCiS2+7GtZV5YjdWJtpRpJd1EVk0R+2aTmnLc5xurmzMeeYO1sl60enFvSDhAjn7T0/WbMpsjrw8J3vPe/7nOf9+T5CCMki0qNRKBR7cC1CFJP/8TScPFXbcrnTeOJ0U7lkgaxMeFaC+semHNxnABsTfCjSAWSv57/K9tuOgeLG7g72hueW4DEzcXsdwo2rbGgaLLt09urx8bpaCgjJTqNAiShA5CHUiHx53YzQruIMK4kKdNUENJBHqEWi0skfhAbVIfSIw4gj8lov248hDiGqSWrh+dz8fNhaqge1oZhoEiS3ElUW42+3EKLYj+J244pToMRA5S5pr9yJgVUkNZuVSmI6gGp6hZRqsM0VSFgOIiF+Sd+MtE3Jkf7QjbWIlBLSWiinqZ3GWiERVS3VTrEGUtU9o4P+kalZPz05E3AFP07Q4ZmAJzbncYUSIWtXzz5T05kypy/uYyKzAfRj6fAHP4MQ3ocDb0MXWq/vFXhMJpNEPBKZASf7Gp4OszDo48Axzgl7np3+Cnftr+rM1hvUWGx+ecAbBRs9wSMJOP1v0C/KB98vQndP38GUERuPfwJ2+guMcknwxudB+IE7muTDySWR8LzZSgUS35ZFH7R70d89NSuAj8wt/0147zltdfpilj431/5oKN7VN8J1DPpiV+zM5DWz5db2JwcMOns/0zng4doc3pjlhSdqRXVijI0OtjebLeV/Ho7VXS5BqFYs2DBEFUKz4SOCzJsE9sZGUFEUlBkMONi4N2EK3wkp4QnRuVyuHCEl2TcF6ShlqQsFWu2PSqNRUoiq1IgdIB2tTG6bIhxodQ2+VBRKQ71NUJjRzfBrhsxtN4/esb3s6T53sR4JK1m9XvEv92E2HX43toCFGWbjQ2t0bsONEQMfOEY77EwI7g+MtmR6H/4E1yN52uNNkvYAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"webrtc turn\"\n        title=\"\"\n        src=\"/static/5926b76eea820b8d89738432822f635f/e4a3f/webrtc-turn.png\"\n        srcset=\"/static/5926b76eea820b8d89738432822f635f/8ff13/webrtc-turn.png 262w,\n/static/5926b76eea820b8d89738432822f635f/e4a3f/webrtc-turn.png 295w\"\n        sizes=\"(max-width: 295px) 100vw, 295px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>\n<h5>SDP(Session Description Protocol)</h5>\n<ul>\n<li>해상도나 형식, 코덱, 암호화등의 멀티미디어 컨텐츠의 연결을 설명하기 위한 표준이다.</li>\n<li>두 개의 peer가 다른 한쪽이 <strong>데이터가 전송되고 있다는 것을 알게 해준다.</strong></li>\n<li>기본적으로 미디어 컨텐츠 자체가 아닌 <strong>컨텐츠에 대한 메타데이터 설명</strong>이다.</li>\n<li><strong>기술적으로 보자면 SDP 는 프로토콜이 아니다.</strong> 그러나 데이터 포멧은 <strong>디바이스간의 미디어를 공유하기 위한 연결을 설명하기 위해 사용</strong>한다.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"참고\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0\" aria-label=\"참고 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[참고]</h2>\n<ul>\n<li><a href=\"https://webrtc.org/\">https://webrtc.org/</a></li>\n<li><a href=\"https://developer.mozilla.org/ko/docs/Web/API/WebRTC_API\">https://developer.mozilla.org/ko/docs/Web/API/WebRTC_API</a></li>\n</ul>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#1-webrtc%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C\">1. WebRTC란 무엇일까?</a></p>\n</li>\n<li>\n<p><a href=\"#2-webrtc%EC%9D%98-%EA%B8%B0%EC%88%A0-%EB%B0%8F-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-%EC%86%8C%EA%B0%9C\">2. WebRTC의 기술 및 프로토콜 소개</a></p>\n<ul>\n<li><a href=\"#2-1-iceinteractive-connectivity-establishment\">2-1. ICE(Interactive Connectivity Establishment)</a></li>\n<li><a href=\"#2-2-stunsession-traversal-utilities-for-nat-%EC%84%9C%EB%B2%84\">2-2. STUN(Session Traversal Utilities for NAT) 서버</a></li>\n<li><a href=\"#2-3-natnetwork-address-transilation\">2-3. NAT(Network Address Transilation)</a></li>\n<li><a href=\"#2-4-turntraversal-using-relays-around-nat-%EC%84%9C%EB%B2%84\">2-4. TURN(Traversal Using Relays around NAT) 서버</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%B0%B8%EA%B3%A0\">[참고]</a></p>\n</li>\n</ul>","frontmatter":{"author":"millo","category":"webrtc","description":"WebRTC 이론 정리하기. ICE, SDP, STUN, TURN, NAT 등에 대해 알아보자.","image":{"childImageSharp":{"fixed":{"src":"/static/5d1a4dc7a92facc014378e28932bee9a/497c6/webrtc.png"}}},"lang":"ko","released_at":"2020-12-22 17:00","series":"WebRTC 이론부터 실전까지","tags":["ICE","SDP","STUN","TURN","WebRTC","NAT"],"title":"WebRTC 이론 정리하기","translation":"/About-WebRTC/","updated_at":"2020-12-22 17:01"},"fields":{"slug":"/WebRTC-이론-정리하기/"}},"allMarkdownRemark":{"nodes":[{"frontmatter":{"lang":"ko","title":"WebRTC 이론 정리하기"},"fields":{"slug":"/WebRTC-이론-정리하기/"}},{"frontmatter":{"lang":"ko","title":"WebRTC 구현 방식(Mesh/P2P, SFU, MCU)"},"fields":{"slug":"/WebRTC-구현-방식-Mesh-SFU-MCU/"}},{"frontmatter":{"lang":"ko","title":"WebRTC 구현하기(1:1 P2P)"},"fields":{"slug":"/WebRTC-구현하기-1-1-P2P/"}},{"frontmatter":{"lang":"ko","title":"WebRTC 구현하기(1:N P2P)"},"fields":{"slug":"/WebRTC-구현하기-1-N-P2P/"}},{"frontmatter":{"lang":"ko","title":"WebRTC 구현하기(1:N SFU)"},"fields":{"slug":"/WebRTC-구현하기-1-N-SFU/"}},{"frontmatter":{"lang":"ko","title":"WebRTC 성능 비교(P2P vs SFU)"},"fields":{"slug":"/WebRTC-성능비교-P2P-vs-SFU/"}}]}},"pageContext":{"slug":"/WebRTC-이론-정리하기/","series":"WebRTC 이론부터 실전까지"}},"staticQueryHashes":["2083168511","3061319093","3557473807","356676075"],"slicesMap":{}}