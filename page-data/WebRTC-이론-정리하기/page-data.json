{"componentChunkName":"component---src-components-post-post-template-tsx","path":"/WebRTC-이론-정리하기/","result":{"data":{"markdownRemark":{"html":"<h2 id=\"1-webrtc란-무엇일까\" style=\"position:relative;\"><a href=\"#1-webrtc%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C\" aria-label=\"1 webrtc란 무엇일까 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. WebRTC란 무엇일까?</h2>\n<ul>\n<li>WebRTC(Web Real-Time Communication)란 웹 브라우저 환경 및 Android, IOS 애플리케이션에서도 사용 가능한 비디오, 음성 및 일반 데이터가 <strong>피어간</strong>에 <strong>실시간</strong>으로 전송되도록 지원하는 <strong>오픈 소스</strong>이다.</li>\n<li>공개 <strong>웹 표준으로 구현</strong>되며 모든 주요 브라우저에서 일반 JavaScript API로 제공한다. (Apple, Google, Microsoft 및 Mozilla가 지원)</li>\n</ul>\n<h2 id=\"2-webrtc의-기술-및-프로토콜-소개\" style=\"position:relative;\"><a href=\"#2-webrtc%EC%9D%98-%EA%B8%B0%EC%88%A0-%EB%B0%8F-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-%EC%86%8C%EA%B0%9C\" aria-label=\"2 webrtc의 기술 및 프로토콜 소개 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. WebRTC의 기술 및 프로토콜 소개</h2>\n<h3 id=\"2-1-iceinteractive-connectivity-establishment\" style=\"position:relative;\"><a href=\"#2-1-iceinteractive-connectivity-establishment\" aria-label=\"2 1 iceinteractive connectivity establishment permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2-1. ICE(Interactive Connectivity Establishment)</h3>\n<ul>\n<li>브라우저가 <strong>peer를 통한 연결이 가능하도록 해주는 프레임 워크</strong>이다.</li>\n<li><strong>peer간 단순 연결 시 작동하지 않는 이유들</strong>\n<ul>\n<li>연결을 시도하는 <strong>방화벽</strong>을 통과해야 함</li>\n<li><strong>단말에 Public IP가 없다</strong>면 유일한 주소값을 할당해야 한다.</li>\n<li><strong>라우터가 peer간의 직접 연결을 허용하지 않을 때</strong> 데이터를 릴레이해야 하는 경우</li>\n</ul>\n</li>\n<li>ICE는 위의 작업들을 수행하기 위해 <strong>STUN</strong>과 <strong>TURN</strong> 서버 <strong>둘 다 혹은 하나</strong>의 서버를 사용한다.</li>\n</ul>\n<h3 id=\"2-2-stunsession-traversal-utilities-for-nat-서버\" style=\"position:relative;\"><a href=\"#2-2-stunsession-traversal-utilities-for-nat-%EC%84%9C%EB%B2%84\" aria-label=\"2 2 stunsession traversal utilities for nat 서버 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2-2. STUN(Session Traversal Utilities for NAT) 서버</h3>\n<ul>\n<li><strong>클라이언트 자신의 Public Address(IP:PORT)를 알려준다.</strong></li>\n<li>peer간의 직접 연결을 막는 등의 라우터의 제한을 결정하는 프로토콜 (현재 <strong>다른 peer가 접근 가능하지 여부</strong> 결정)</li>\n<li>클라이언트는 인터넷을 통해 <strong>클라이언트의 Public Address</strong>와 <strong>라우터의 NAT 뒤에 있는 클라이언트가 접근 가능한지에 대한 답변</strong>을 STUN서버에 요청한다.</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 259px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/f3467aed345c1199ea1e3ddd5928b672/a2ead/webrtc-stun.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 145.94594594594594%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAdCAYAAACqhkzFAAAACXBIWXMAAAsTAAALEwEAmpwYAAADeklEQVR42qVVa0hTcRQ/2t4+s3JZJoprrehhmiUhRBB9CaIv+xL0JaHPrU8RRFSw6IPQCpKKHkONnI8syXLTpVE6bQ/DLOu6ZvbQ9SCpbKLbTud/d7NruNrWgR/////ce3/ncc85fwCA5XK5vFBTVLREV1q6KBVgMfynrACQbKJ1KyEPZLJVgj4pYcbDxkqNpd1hut768ESFwZDFKxETJpRarA6Ha2QC+4Y/4Y3WR7URPkxOiG3Xrr0LbS5uvJf7OOMmUrub6yV1sihsMWKTi5aWU3d6BvFmlydoMjftZzqLxbJgnlwm/WEIohhzSo8frdxuMhwpQ4D0MIBceCATwM6KGP1zSqVS3EhZKyAy5bREUR4AKOCTC1BEyxZCsVAFioiaN6IkSAip8NsBPv10QE16OvJ/FyElm4g1hCX0lVYgZLW5gS8rgEJCPkSM5RDKCStF4SNZRXoJM4B/I0flpQ+JUEvInufn/EsYYUBDaxodVBTFNlq1k9RBRKgTkcYqcwhTWddQqKtpz0JXEwrK9Hrlnn37Fu3U67N26iuy9AwVAkRn9lxMmBExkKNiidcDLKDiTiLC/KtnLxutnpFvds+rMbvH5+9w+/ztLq/f5uR4WB+/9HcOjPqrb3f6xTnMFDyezRMR8rVYb+0xjkwi66Sg0/cFWVc9HZvCF5/D+PxjEJ99mEHvV0QixxgJHSe7h/x4pf7etLm5I3TmSl2orq07dL6mOXS5/m6oqvZWqMHWF7rreB6KibDR2mscDSAOjAWCg+NT+OTtdxwcn0anb4L2k+h5/RWHPoXR3u/7u4e/2u+cuemQ1e193+4aHrI5vVy728vZnMNch+cV7QmkezDwhjM327mohCjUHK1L3wOsOadULgO1OkUNkKJmKwHm7Gd10T1kQm1YKHROptjQP+pwLqHIu4UYKXCGWOdjWB4lZAlhhYDMODpllKbGlPYX4TE4liwQqmmM5TLv4m09IkK6pDB1VkNjCiMDgkEVJ6EiT5WhK9atL9fqdDotpKXxU+ZHJFR1jD9ijuRKpbCW1lI273ZIJJuIIEfInSyhi6qy6trme46hW82d/dWXDIdZiawLyOWaRLxjomy67xqkWw8dLz9gg93VwkY7HrggTci7kpIdGdRG7/rffOenRlvfi+55brn4xGRuPFjT0hUmTJw+X737j2s0LvkJhnW+L58BDlgAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"webrtc stun\"\n        title=\"\"\n        src=\"/static/f3467aed345c1199ea1e3ddd5928b672/a2ead/webrtc-stun.png\"\n        srcset=\"/static/f3467aed345c1199ea1e3ddd5928b672/a2ead/webrtc-stun.png 259w\"\n        sizes=\"(max-width: 259px) 100vw, 259px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3 id=\"2-3-natnetwork-address-transilation\" style=\"position:relative;\"><a href=\"#2-3-natnetwork-address-transilation\" aria-label=\"2 3 natnetwork address transilation permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2-3. NAT(Network Address Transilation)</h3>\n<ul>\n<li>단말에 공개 IP(Public IP) 주소를 할당하기 위해 사용한다.</li>\n<li>라우터는 공개 IP 주소를 갖고 있고 모든 단말들은 라우터에 연결되어 있으며 비공개 IP주소(Private IP Address)를 갖는다.</li>\n<li>요청은 단말의 비공개 주소로부터 라우터의 공개 주소와 유일한 포트를 기반으로 번역한다. 이 덕분에, <strong>각각의 단말이 유일한 공개 IP 없이 인터넷 상에서 검색 가능하다.</strong></li>\n<li>몇몇의 라우터들은 <strong>Symmetric NAT</strong>이라고 불리우는 <strong>제한을 위한 NAT</strong>을 채용한다. 즉, <strong>peer들이 오직 이전에 연결한 적 있는 연결들만 허용</strong>한다. 따라서 <strong>STUN서버에 의해 공개 IP주소를 발견한다고 해도 모두가 연결을 할수 있다는 것은 아니다.</strong> (위의 설명에서 STUN 서버에 다른 peer가 접근 가능한지 여부를 요청하는 이유)</li>\n<li><strong>이를 위해 TURN이 필요하다.</strong></li>\n</ul>\n<h3 id=\"2-4-turntraversal-using-relays-around-nat-서버\" style=\"position:relative;\"><a href=\"#2-4-turntraversal-using-relays-around-nat-%EC%84%9C%EB%B2%84\" aria-label=\"2 4 turntraversal using relays around nat 서버 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2-4. TURN(Traversal Using Relays around NAT) 서버</h3>\n<ul>\n<li><strong>TURN 서버와 연결하고 모든 정보를 그 서버에 전달</strong>하는 것으로 <strong>Symmetric NAT 제한을 우회</strong>하는 것을 의미한다.</li>\n<li>이를 위해 <strong>TURN 서버와 연결</strong>을 한 후 <strong>모든 peer들에게 저 서버에 모든 패킷을 보내고 다시 나(TURN서버)에게 전달</strong>해달라고 해야 한다.</li>\n<li>명백히 <strong>오버헤드가 발생</strong>하므로 이 방법은 다른 <strong>대안이 없을 경우만 사용</strong>해야 한다.</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 295px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/5926b76eea820b8d89738432822f635f/e4a3f/webrtc-turn.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 100.76335877862594%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAsTAAALEwEAmpwYAAAC8UlEQVR42qWUa0hTcRTA/5rOPVympmO2qZhhWaxEIbFEoqKCCKIPBRFCRH3oa1EkcQP9lHOhptQH6YNgDy3JOdM5nXk3W+5uNffQTdPssU2DHoS9hJ3OdXfiY4nNP/w4/8e5557/Oed/CCEkigRHPI/Hy0WZhGwkaxkAMGf0xKkzBdTNuksnSy9kcgdRkdib/0htsD9z+v/AU731Afej6JX0l+xFLfNQTVtb7b5f0PLc1rCCwdV7efpch6ziWu1x+sCedFjsScgDHiJG+IgQEXFyA7e/cDh4hA/yHAJi4JP0GSKQcQcpSDFSgOxFDnFyHycPI0VI7tLU8EQikEgOgig3hcRPErIZvUxZH8x6HrIN2c7JrZzcgmQj4UIDeB1Ab/TxuNiJac5Ag+zVk+ZOwycjNKLnk1JYWCjIziZxiYlXEvj87nRCriYLhURKxGnJjwgR/ECjColERKRSoRSRsHOMGysVCgU7X7fIdBs9xBhH/Azt9Fn0Nu9rVpo8Uyb90OSQsr4pjzp7MU3HjA0ahv0Wo8tnpp1exjDsxW985t5XEzaqsn4Ha4eiqOC1jS4vdDNj8KSHAa3ZDV2DbnYdsEx8g0Z1X3G5sk5uck/PdppGoK3fFui1joPO8gb1RgK29zNwt6l996ISM3mmwTz+BYzDPkDPgHZ8AIPLG7B7f0Jja19xWblSzrz9Omse/8zqBFh92vVxTsfh/73c4H0NrdJZPVWaAU91S7fnjsY4VoMeKtsN9lpKVZ/1uKRE1t5huN1ldt/SMp6qzpdulXZwVIVhqFLTtuqy8sqMhY9jaZZTEUFoR09IDATLR7zqJ6IHiGHdPXoehPIcSCs6hoWNawph6zBAiIxhmFhcx+jDEKaBhDY+iePiIIsqBT5Xd0IkC4JPK5Juk4zXEu7CSWYCgoY2fSckNaLOEKqhipqGI/fa+prvXL6+n40dk58fu5Z+GN3vePdiCgPYw4zq/pG5/+vYzVpTjWbACQ+7jDci7Yd/AR8cgBayvsO/AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"webrtc turn\"\n        title=\"\"\n        src=\"/static/5926b76eea820b8d89738432822f635f/e4a3f/webrtc-turn.png\"\n        srcset=\"/static/5926b76eea820b8d89738432822f635f/8ff13/webrtc-turn.png 262w,\n/static/5926b76eea820b8d89738432822f635f/e4a3f/webrtc-turn.png 295w\"\n        sizes=\"(max-width: 295px) 100vw, 295px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>\n<h5>SDP(Session Description Protocol)</h5>\n<ul>\n<li>해상도나 형식, 코덱, 암호화등의 멀티미디어 컨텐츠의 연결을 설명하기 위한 표준이다.</li>\n<li>두 개의 peer가 다른 한쪽이 <strong>데이터가 전송되고 있다는 것을 알게 해준다.</strong></li>\n<li>기본적으로 미디어 컨텐츠 자체가 아닌 <strong>컨텐츠에 대한 메타데이터 설명</strong>이다.</li>\n<li><strong>기술적으로 보자면 SDP 는 프로토콜이 아니다.</strong> 그러나 데이터 포멧은 <strong>디바이스간의 미디어를 공유하기 위한 연결을 설명하기 위해 사용</strong>한다.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"참고\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0\" aria-label=\"참고 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[참고]</h2>\n<ul>\n<li><a href=\"https://webrtc.org/\">https://webrtc.org/</a></li>\n<li><a href=\"https://developer.mozilla.org/ko/docs/Web/API/WebRTC_API\">https://developer.mozilla.org/ko/docs/Web/API/WebRTC_API</a></li>\n</ul>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#1-webrtc%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C\">1. WebRTC란 무엇일까?</a></p>\n</li>\n<li>\n<p><a href=\"#2-webrtc%EC%9D%98-%EA%B8%B0%EC%88%A0-%EB%B0%8F-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-%EC%86%8C%EA%B0%9C\">2. WebRTC의 기술 및 프로토콜 소개</a></p>\n<ul>\n<li><a href=\"#2-1-iceinteractive-connectivity-establishment\">2-1. ICE(Interactive Connectivity Establishment)</a></li>\n<li><a href=\"#2-2-stunsession-traversal-utilities-for-nat-%EC%84%9C%EB%B2%84\">2-2. STUN(Session Traversal Utilities for NAT) 서버</a></li>\n<li><a href=\"#2-3-natnetwork-address-transilation\">2-3. NAT(Network Address Transilation)</a></li>\n<li><a href=\"#2-4-turntraversal-using-relays-around-nat-%EC%84%9C%EB%B2%84\">2-4. TURN(Traversal Using Relays around NAT) 서버</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%B0%B8%EA%B3%A0\">[참고]</a></p>\n</li>\n</ul>","frontmatter":{"author":"millo","category":"webrtc","description":"WebRTC 이론 정리하기. ICE, SDP, STUN, TURN, NAT 등에 대해 알아보자.","image":{"childImageSharp":{"fixed":{"src":"/static/5d1a4dc7a92facc014378e28932bee9a/497c6/webrtc.png"}}},"lang":"ko","released_at":"2020-12-22 17:00","series":"WebRTC 이론부터 실전까지","tags":["ICE","SDP","STUN","TURN","WebRTC","NAT"],"title":"WebRTC 이론 정리하기","translation":"/About-WebRTC/","updated_at":"2020-12-22 17:01"},"fields":{"slug":"/WebRTC-이론-정리하기/"}},"allMarkdownRemark":{"nodes":[{"frontmatter":{"lang":"ko","title":"WebRTC 이론 정리하기"},"fields":{"slug":"/WebRTC-이론-정리하기/"}},{"frontmatter":{"lang":"ko","title":"WebRTC 구현 방식(Mesh/P2P, SFU, MCU)"},"fields":{"slug":"/WebRTC-구현-방식-Mesh-SFU-MCU/"}},{"frontmatter":{"lang":"ko","title":"WebRTC 구현하기(1:1 P2P)"},"fields":{"slug":"/WebRTC-구현하기-1-1-P2P/"}},{"frontmatter":{"lang":"ko","title":"WebRTC 구현하기(1:N P2P)"},"fields":{"slug":"/WebRTC-구현하기-1-N-P2P/"}},{"frontmatter":{"lang":"ko","title":"WebRTC 구현하기(1:N SFU)"},"fields":{"slug":"/WebRTC-구현하기-1-N-SFU/"}},{"frontmatter":{"lang":"ko","title":"WebRTC 성능 비교(P2P vs SFU)"},"fields":{"slug":"/WebRTC-성능비교-P2P-vs-SFU/"}}]}},"pageContext":{"slug":"/WebRTC-이론-정리하기/","series":"WebRTC 이론부터 실전까지"}},"staticQueryHashes":["104535566","2083168511","3061319093","3557473807","356676075","3868781503"],"slicesMap":{}}